package com.bamboo.ebooks.design_pattern.singleton;

/**
 * 多线程的情况可以用。（懒汉式，不好）
 * 考虑线程安全的写法
 *
 * 这种写法考虑了线程安全，将对singleton的null判断以及new的部分使用synchronized进行加锁。
 * 同时，对singleton对象使用volatile关键字进行限制，保证其对所有线程的可见性，
 * 并且禁止对其进行指令重排序优化。如此即可从【语义】上保证这种单例模式写法是线程安全的。
 *
 * 这种写法是可以正确运行的，但是其效率低下，还是无法实际应用。
 * 因为每次调用getSingleton()方法，都必须在synchronized这里进行排队，
 * 而真正遇到需要new的情况是非常少的。
 */
public class Singleton_03 {

    /**
     * 从语义角度来看，并没有什么问题。但是其实还是有坑。说这个坑之前我们要先来看看volatile这个关键字。其
     * 实这个关键字有两层语义。
     * 第一层语义相信大家都比较熟悉，就是可见性。
     * 可见性指的是在一个线程中对该变量的修改会马上由工作内存（Work Memory）写回主内存（Main Memory），
     * 所以会马上反应在其它线程的读取操作中。顺便一提，工作内存和主内存可以近似理解为实际电脑中的高速缓存和主存，
     * 工作内存是线程独享的，主存是线程共享的。
     *
     * volatile的第二层语义是禁止指令重排序优化。大家知道我们写的代码（尤其是多线程代码），由于编译器优化，
     * 在实际执行的时候可能与我们编写的顺序不同。编译器只保证程序执行结果与源代码相同，却不保证实际指令的顺序与源代码相同。
     * 这在单线程看起来没什么问题，然而一旦引入多线程，这种乱序就可能导致严重问题。volatile关键字就可以从语义上解决这个问题。
     *
     * 注意，前面反复提到“从语义上讲是没有问题的”，但是很不幸，禁止指令重排优化这条语义直到jdk1.5以后才能正确工作。
     * 此前的JDK中即使将变量声明为volatile也无法完全避免重排序所导致的问题。所以，在jdk1.5版本前，
     * 双重检查锁形式的单例模式是无法保证线程安全的。
     */
    private static volatile Singleton_03 instance = null;
    private Singleton_03(){}

    /**
     * 加上了同步锁，使得在多线程的情况下可以用。例如：当两个线程同时想创建实例，由于在一个时刻只有一个线程能得到同步锁，
     * 当第一个线程加上锁以后，第二个线程只能等待。第一个线程发现实例没有创建，创建之。
     * 第一个线程释放同步锁，第二个线程才可以加上同步锁，执行下面的代码。由于第一个线程已经创建了实例，所以第二个线程不需要创建实例。
     * 保证在多线程的环境下也只有一个实例。
     *
     * 缺点：每次通过getInstance方法得到singleton实例的时候都有一个试图去获取同步锁的过程。而众所周知，加锁是很耗时的。能避免则避免。
     * @return
     */
    public static Singleton_03 getInstance() {
        synchronized (Singleton_03.class) {
            if (null == instance) {
                instance = new Singleton_03();
            }
        }
        return instance;
    }

}
